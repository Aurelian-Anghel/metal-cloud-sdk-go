//go:generate go run helper/docgen.go - $GOFILE ./ OSAsset OSAsset

package metalcloud

import "fmt"

// OSAsset struct defines a server type
type OSAsset struct {
	// description: Id of the object
	OSAssetID int `json:"os_asset_id,omitempty" yaml:"id,omitempty"`
	// description: Id of the owner of this object
	UserIDOwner int `json:"user_id_owner,omitempty" yaml:"ownerID,omitempty"`
	// description: Id of the user who created this object (may be different than the owner). Readonly.
	UserIDAuthenticated int `json:"user_id_authenticated,omitempty" yaml:"userIDAuthenticated,omitempty"`
	// description: The file name as it will be seen in the final template
	// example: /tmp/newfile1
	OSAssetFileName string `json:"os_asset_filename,omitempty" yaml:"fileName,omitempty"`
	// description: The size of the file
	OSAssetFileSizeBytes int `json:"os_asset_file_size_bytes,omitempty" yaml:"fileSizeBytes,omitempty"`
	// description: Type of file as a mime type. Both types are stored in the database but the text type will be interpreted for variables.
	// values:
	//     - application/octet-stream
	//     - text/plain
	OSAssetFileMime string `json:"os_asset_file_mime,omitempty" yaml:"fileMime,omitempty"`
	// description: Type of asset. Required for text type files. It controls the type of template language used when interpreting the files. Simple - uses simple search and replace. Advanced - uses jinja2 template language.
	// values:
	//   - none
	//   - simple
	//   - advanced
	OSAssetTemplateType string `json:"os_asset_template_type,omitempty" yaml:"templateType,omitempty"`
	// description: the actual contents in base64 format.
	OSAssetContentsBase64 string `json:"os_asset_contents_base64,omitempty" yaml:"contentBase64,omitempty"`
	// description: A hash of the content
	OSAssetContentsSHA256Hex string `json:"os_asset_contents_sha256_hex,omitempty" yaml:"contentSHA256Hex,omitempty"`
	// description: The asset's intended usage
	// values:
	//	 - build_component
	OSAssetUsage string `json:"os_asset_usage,omitempty" yaml:"usage,omitempty"`
	// description: If set then the content of this asset will not be stored in the database. Instead it will be pulled from this URL when needed.
	// example: https://repo.metalsoft.io/test-12/test.iso
	OSAssetSourceURL string `json:"os_asset_source_url,omitempty" yaml:"sourceURL,omitempty"`
	// description: A list of required custom variables for the asset to be generated. Automatically generated by parsing the file.
	OSAssetVariableNamesRequired []string `json:"os_asset_variable_names_required,omitempty" yaml:"variables,omitempty"`
	// description: A list o tags
	OSAssetTags []string `json:"os_asset_tags,omitempty" yaml:"tags,omitempty"`
	// description: ISO 8601 timestamp which holds the date and time when the asset was created.
	// example: 2013-11-29T13:00:01Z
	OSAssetCreatedTimestamp string `json:"os_asset_created_timestamp,omitempty" yaml:"createdTimestamp,omitempty"`
	// description: ISO 8601 timestamp which holds the date and time when the asset was last updated.
	// example: 2013-11-29T13:00:01Z
	OSAssetUpdatedTimestamp string `json:"os_asset_updated_timestamp,omitempty" yaml:"updatedTimestamp,omitempty"`
}

// OSAssetCreate creates a osAsset object
func (c *Client) OSAssetCreate(osAsset OSAsset) (*OSAsset, error) {
	var createdObject OSAsset

	userID := c.GetUserID()

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_create",
		userID,
		osAsset)

	if err != nil {
		return nil, err
	}

	return &createdObject, nil
}

// OSAssetDelete permanently destroys a OSAsset.
func (c *Client) OSAssetDelete(osAssetID int) error {

	if err := checkID(osAssetID); err != nil {
		return err
	}

	resp, err := c.rpcClient.Call("os_asset_delete", osAssetID)

	if err != nil {
		return err
	}

	if resp.Error != nil {
		return fmt.Errorf(resp.Error.Message)
	}

	return nil
}

// OSAssetUpdate updates a osAsset
func (c *Client) OSAssetUpdate(osAssetID int, osAsset OSAsset) (*OSAsset, error) {
	var createdObject OSAsset

	if err := checkID(osAssetID); err != nil {
		return nil, err
	}

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_update",
		osAssetID,
		osAsset)

	if err != nil {

		return nil, err
	}

	return &createdObject, nil
}

// OSAssetGet returns a OSAsset specified by nOSAssetID. The OSAsset's protected value is never returned.
func (c *Client) OSAssetGet(osAssetID int) (*OSAsset, error) {

	var createdObject OSAsset

	if err := checkID(osAssetID); err != nil {
		return nil, err
	}

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_get",
		osAssetID)

	if err != nil {

		return nil, err
	}

	return &createdObject, nil
}

// OSAssetGetStoredContent returns the content of an OSAsset specified by nOSAssetID.
func (c *Client) OSAssetGetStoredContent(osAssetID int) (string, error) {

	var createdObject string

	if err := checkID(osAssetID); err != nil {
		return "", err
	}

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_get_stored_content",
		osAssetID)

	if err != nil {

		return "", err
	}

	return createdObject, nil
}

// OSAssets retrieves a list of all the OSAsset objects which a specified User is allowed to see through ownership or delegation. The OSAsset objects never return the actual protected OSAsset value.
func (c *Client) OSAssets() (*map[string]OSAsset, error) {
	userID := c.GetUserID()

	resp, err := c.rpcClient.Call(
		"os_assets",
		userID,
	)
	if err != nil {
		return nil, err
	}

	if resp.Error != nil {
		return nil, fmt.Errorf(resp.Error.Message)
	}

	_, ok := resp.Result.([]interface{})

	if ok {
		var m = map[string]OSAsset{}
		return &m, nil
	}

	var createdObject map[string]OSAsset

	err = resp.GetObject(&createdObject)

	if err != nil {
		return nil, err
	}

	return &createdObject, nil
}

// OSAssetMakePublic makes an OS Asset public
func (c *Client) OSAssetMakePublic(osAssetID int) (*OSAsset, error) {
	var createdObject OSAsset

	if err := checkID(osAssetID); err != nil {
		return nil, err
	}

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_make_public",
		osAssetID)

	if err != nil {
		return nil, err
	}

	return &createdObject, nil
}

// OSAssetMakePrivate makes an OS Asset private and owned by the current user
func (c *Client) OSAssetMakePrivate(osAssetID int, userID int) (*OSAsset, error) {
	var createdObject OSAsset

	if err := checkID(osAssetID); err != nil {
		return nil, err
	}

	if err := checkID(userID); err != nil {
		return nil, err
	}

	err := c.rpcClient.CallFor(
		&createdObject,
		"os_asset_make_private",
		osAssetID,
		userID)

	if err != nil {
		return nil, err
	}

	return &createdObject, nil
}

// CreateOrUpdate implements interface Applier
func (asset OSAsset) CreateOrUpdate(client MetalCloudClient) error {
	var err error
	var result *OSAsset
	err = asset.Validate()

	if err != nil {
		return err
	}

	if asset.OSAssetID != 0 {
		result, err = client.OSAssetGet(asset.OSAssetID)
	} else {
		assets, err := client.OSAssets()
		if err != nil {
			return err
		}

		for _, a := range *assets {
			if a.OSAssetFileName == asset.OSAssetFileName {
				result = &a
			}
		}
	}

	if result == nil {
		_, err = client.OSAssetCreate(asset)

		if err != nil {
			return err
		}
	} else {
		_, err = client.OSAssetUpdate(asset.OSAssetID, asset)

		if err != nil {
			return err
		}
	}

	return nil
}

// Delete implements interface Applier
func (asset OSAsset) Delete(client MetalCloudClient) error {
	var result *OSAsset
	var id int

	err := asset.Validate()

	if err != nil {
		return err
	}

	if asset.OSAssetID != 0 {
		id = asset.OSAssetID
	} else {
		assets, err := client.OSAssets()
		if err != nil {
			return err
		}

		for _, a := range *assets {
			if a.OSAssetFileName == asset.OSAssetFileName {
				result = &a
			}
		}

		id = result.OSAssetID
	}

	err = client.OSAssetDelete(id)

	if err != nil {
		return err
	}

	return nil
}

// Validate implements interface Applier
func (asset OSAsset) Validate() error {
	if asset.OSAssetID == 0 && asset.OSAssetFileName == "" {
		return fmt.Errorf("id is required")
	}
	return nil
}
