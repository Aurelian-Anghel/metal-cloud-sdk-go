package metalcloud

//go:generate bash -c "ifacemaker -f '*.go' -i MetalCloudClient -p metalcloud -s Client -o metal_cloud_client.go -c 'Code generated by ifacemaker; DO NOT EDIT.' -y 'MetalCloudClient interface used for mocking and abstracting the backend'"
//go:generate go run scripts/fix_package.go -input metal_cloud_client.go
import (
	"bytes"
	"crypto/hmac"
	"crypto/md5"
	"encoding/hex"
	"errors"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/ybbus/jsonrpc"
	"golang.org/x/net/context"
	"golang.org/x/oauth2/clientcredentials"
)

// Client struct defines a metalcloud client
type Client struct {
	rpcClient jsonrpc.RPCClient
	user      string
	apiKey    string
	endpoint  string
	userID    int
}
type ClientOptions struct {
	User           string
	ApiKey         string
	Endpoint       string
	UserID         int
	LoggingEnabled bool
	ClientId       string
	ClientSecret   string
	TokenURL       string
	Timeout        time.Duration
}

func GetMetalcloudClient(user string, apiKey string, endpoint string, loggingEnabled bool, clientId string, clientSecret string, tokenURL string) (*Client, error) {
	return GetMetalcloudClientWithOptions(ClientOptions{
		User:           user,
		ApiKey:         apiKey,
		Endpoint:       endpoint,
		UserID:         0,
		LoggingEnabled: loggingEnabled,
		ClientId:       clientId,
		ClientSecret:   clientSecret,
		TokenURL:       tokenURL,
		Timeout:        5 * time.Minute,
	})
}

// GetMetalcloudClient returns a metal cloud client
func GetMetalcloudClientWithOptions(options ClientOptions) (*Client, error) {

	if options.User == "" {
		return nil, errors.New("user cannot be an empty string! It is typically in the form of user's email address")
	}

	if options.Endpoint == "" {
		return nil, errors.New("endpoint cannot be an empty string! It is typically in the form of user's email address")
	}

	if options.ApiKey == "" && (options.ClientId == "" || options.ClientSecret == "" || options.TokenURL == "") {
		return nil, errors.New("no authorization method was set(OAuth or API key)")
	}

	userID := 0
	oAuthToken := ""

	if options.ClientId != "" && options.ClientSecret != "" && options.TokenURL != "" {

		config := clientcredentials.Config{
			ClientID:     options.ClientId,
			ClientSecret: options.ClientSecret,
			TokenURL:     options.TokenURL,
		}

		oAuthTokenResp, errOauth := config.Token(context.Background())
		if errOauth != nil {
			panic(errOauth)
		}
		oAuthToken = (*oAuthTokenResp).AccessToken
		n, err := strconv.Atoi(options.ClientId)
		if err != nil {
			return nil, err
		}
		userID = n
	} else {
		components := strings.Split(options.ApiKey, ":")
		if len(components) > 1 {
			n, err := strconv.Atoi(components[0])
			if err != nil {
				return nil, err
			}
			userID = n
		}
	}

	_, err := url.ParseRequestURI(options.Endpoint)
	if err != nil {
		return nil, err
	}

	transport := &signatureAdderRoundTripper{
		APIKey:         options.ApiKey,
		LoggingEnabled: options.LoggingEnabled,
		OAuthToken:     oAuthToken,
	}

	httpClient := &http.Client{
		Transport: transport,
		Timeout:   options.Timeout,
	}

	rpcClient := jsonrpc.NewClientWithOpts(options.Endpoint, &jsonrpc.RPCClientOpts{
		HTTPClient: httpClient,
	})

	return &Client{
		rpcClient: rpcClient,
		user:      options.User,
		apiKey:    options.ApiKey,
		endpoint:  options.Endpoint,
		userID:    userID,
	}, nil

}

// GetUserEmail returns the user configured for this connection
func (c *Client) GetUserEmail() string {
	return c.user
}

// GetEndpoint returns the endpoint configured for this connection
func (c *Client) GetEndpoint() string {
	return c.endpoint
}

// GetUserID returns the ID of the user extracted from the API key
func (c *Client) GetUserID() int {
	return c.userID
}

type signatureAdderRoundTripper struct {
	APIKey string
	http.RoundTripper
	LoggingEnabled bool
	DryRun         bool
	OAuthToken     string
}

func (c *signatureAdderRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {

	components := strings.Split(c.APIKey, ":")

	var strKeyMetaData *string

	strKeyMetaData = nil

	if len(components) > 1 {
		strKeyMetaData = &components[0]
	}

	key := []byte(c.APIKey)

	var err error

	// Read the content
	var message []byte
	if req.Body != nil {
		message, err = ioutil.ReadAll(req.Body)
		if err != nil {
			return nil, err
		}
	}

	if c.LoggingEnabled {
		log.Printf("%s call to:%s\n", req.Method, req.URL)
		log.Println(string(message))
	}

	//update 2.11.5 -> this was commented as it seemes to genrate issues such as net/http: cannot rewind body after connection loss
	//force close connection. This will avoid the keep-alive related issues for go < 1.6 https://go-review.googlesource.com/c/go/+/3210
	//req.Close = true

	// Restore the io.ReadCloser to its original state
	req.Body = io.NopCloser(bytes.NewBuffer(message))

	if c.OAuthToken != "" {
		req.Header.Set("Authorization", "Bearer "+c.OAuthToken)
	} else {
		hmac := hmac.New(md5.New, key)
		hmac.Write(message)

		var signature = hex.EncodeToString(hmac.Sum(nil))

		values, err := url.ParseQuery(req.URL.RawQuery)
		if err != nil {
			log.Fatal(err)
		}

		if strKeyMetaData != nil {
			signature = *strKeyMetaData + ":" + signature
		}

		values.Add("verify", signature)

		url := req.URL
		url.RawQuery = values.Encode()
		req.URL = url
	}

	var resp *http.Response

	if !c.DryRun {
		resp, err = http.DefaultTransport.RoundTrip(req)
	}

	if c.LoggingEnabled && resp != nil {
		//log the reply
		if resp.Body != nil {
			message, _ = ioutil.ReadAll(resp.Body)
		}

		log.Println(string(message))

		// Restore the io.ReadCloser to its original state
		resp.Body = ioutil.NopCloser(bytes.NewBuffer(message))
	}

	return resp, err
}
